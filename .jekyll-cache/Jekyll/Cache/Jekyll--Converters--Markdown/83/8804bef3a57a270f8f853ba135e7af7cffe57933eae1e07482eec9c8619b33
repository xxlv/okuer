I"_<h1 id="table-of-contents">Table of Contents</h1>

<ol>
  <li><a href="#org8044420">JVM相关调优[Updating]</a>
    <ol>
      <li><a href="#org7956355">工具</a>
        <ol>
          <li><a href="#org56dacb3">jstat</a></li>
          <li><a href="#orge7b53ad">jps</a></li>
          <li><a href="#org09c1441">jstack</a></li>
          <li><a href="#org88fbc97">jmap</a></li>
          <li><a href="#org68b0dcf">分析工具</a></li>
        </ol>
      </li>
      <li><a href="#orge7d1659">指标</a>
        <ol>
          <li><a href="#org046aa48">gclog文件</a></li>
          <li><a href="#org6eecded">jstat 指标</a></li>
        </ol>
      </li>
      <li><a href="#org7f45868">典型场景</a></li>
    </ol>
  </li>
</ol>

<p><a id="org8044420"></a></p>

<h1 id="jvm相关调优updating">JVM相关调优[Updating]</h1>

<p><a id="org7956355"></a></p>

<h2 id="工具">工具</h2>

<p><a id="org56dacb3"></a></p>

<h3 id="jstat">jstat</h3>

<p><a id="orge7b53ad"></a></p>

<h3 id="jps">jps</h3>

<p><a id="org09c1441"></a></p>

<h3 id="jstack">jstack</h3>

<p><a id="org88fbc97"></a></p>

<h3 id="jmap">jmap</h3>

<ol>
  <li>jmap -dump:format=b,file=/tmp/heap.hprof 1</li>
</ol>

<p><a id="org68b0dcf"></a></p>

<h3 id="分析工具">分析工具</h3>

<ol>
  <li>
    <p>top -p $PID -H 查看当前PID的线程</p>
  </li>
  <li>
    <p>mat 分析jmap dump 文件</p>
  </li>
  <li>
    <p>python scripts</p>

    <ol>
      <li>
        <p>Auto dump with specify PID</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> #!/usr/bin/python3 
import os 
import sys 
import time 
from datetime import datetime
        
def execute(cmd):
    print("正在执行 {}".format(cmd))
    os.system(cmd)
        
def change_dir(dirname):
    if not os.path.isdir(dirname):
        print("{} 目录不存在，请检查!".format(dirname))
        sys.exit(-1)
        
    before = os.getcwd()
    os.chdir(dirname)
    print("change dir from {}, to {}".format(before,os.getcwd()))
        
def auto_dump(change_to_path,pid):
    change_dir(change_to_path)
        
    now=datetime.now()
    #  create new dir 
    now_str="{}".format(now.strftime("%Y%m%d%H%M%S"))
        
    work_dir=now_str
    os.mkdir(work_dir)
    change_dir(work_dir)
    # jstack 
        
    cmds=[]
        
    cmd1="""
        jstack {} &gt; jstack-{}.txt
    """.format(pid,now_str)
            
    hprof="{}.hprof".format(now_str)
        
    cmd2="""
        jmap -dump:format=b,file={}  {} &amp;&amp; gzip {} 
    """.format(hprof,pid,hprof)
        
    cmds.append(cmd1)
    cmds.append(cmd2)
        
    for cmd in cmds:
        execute(cmd)
        
if __name__=='__main__':
        
    work_parent_dir="/data"
    pid=376
            
    auto_dump(work_parent_dir,pid)
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ol>

<p><a id="orge7d1659"></a></p>

<h2 id="指标">指标</h2>

<p><a id="org046aa48"></a></p>

<h3 id="gclog文件">gclog文件</h3>

<p><a id="org6eecded"></a></p>

<h3 id="jstat-指标">jstat 指标</h3>

<ol>
  <li>
    <p>jstat -gc  $PID</p>

    <p>查询asd的PID 的GC情况
S0C：asd第一个幸存区的大小
S1C：asd第二个幸存区的大小
S0U：asd第一个幸存区的使用大小
S1U：asd第二个幸存区的使用大小
EC：asd区的大小
EU：asd区的使用大小
OC：asd大小
OU：asd使用大小
MC：asd大小
MU：asd使用大小
CCSCasd类空间大小
CCSUasd类空间使用大小
YGC：asd年轻代垃圾回收次数
YGCTasd代垃圾回收消耗时间
FGC：asd老年代垃圾回收次数
FGCTasd代垃圾回收消耗时间
GCT：垃圾回收消耗总时间</p>
  </li>
  <li>
    <p>jstat -gccapaciy $PID</p>

    <p>NGCMN：新生代最小容量
NGCMX：新生代最大容量
NGC：当前新生代容量
S0C：第一个幸存区大小
S1C：第二个幸存区的大小
EC：伊甸园区的大小
OGCMN：老年代最小容量
OGCMX：老年代最大容量
OGC：当前老年代大小
OC:当前老年代大小
MCMN:最小元数据容量
MCMX：最大元数据容量
MC：当前元数据空间大小
CCSMN：最小压缩类空间大小
CCSMX：最大压缩类空间大小
CCSC：当前压缩类空间大小
YGC：年轻代gc次数
FGC：老年代GC次数</p>
  </li>
  <li>
    <p>jstat -gcnew $PID</p>

    <p>S0C：第一个幸存区大小
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
TT:对象在新生代存活的次数
MTT:对象在新生代存活的最大次数
DSS:期望的幸存区大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间</p>
  </li>
  <li>
    <p>jstat -gcnewcapacity $PID</p>

    <p>NGCMN：新生代最小容量
NGCMX：新生代最大容量
NGC：当前新生代容量
S0CMX：最大幸存1区大小
S0C：当前幸存1区大小
S1CMX：最大幸存2区大小
S1C：当前幸存2区大小
ECMX：最大伊甸园区大小
EC：当前伊甸园区大小
YGC：年轻代垃圾回收次数
FGC：老年代回收次数</p>
  </li>
  <li>
    <p>jstat -gcold $PID</p>

    <p>MC：方法区大小
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
OC：老年代大小
OU：老年代使用大小
YGC：年轻代垃圾回收次数
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间</p>
  </li>
  <li>
    <p>jstat -gcoldcapacity $PID</p>

    <p>OGCMN：老年代最小容量
OGCMX：老年代最大容量
OGC：当前老年代大小
OC：老年代大小
YGC：年轻代垃圾回收次数
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间</p>
  </li>
  <li>
    <p>jstat -gcmetacapacity $PID</p>

    <p>MCMN: 最小元数据容量
MCMX：最大元数据容量
MC：当前元数据空间大小
CCSMN：最小压缩类空间大小
CCSMX：最大压缩类空间大小
CCSC：当前压缩类空间大小
YGC：年轻代垃圾回收次数
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间</p>
  </li>
  <li>
    <p>jstat -gcutil $PID</p>

    <p>S0：幸存1区当前使用比例
S1：幸存2区当前使用比例
E：伊甸园区使用比例
O：老年代使用比例
M：元数据区使用比例
CCS：压缩使用比例
YGC：年轻代垃圾回收次数
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间</p>
  </li>
  <li>
    <p>jstat -printcompilation $PID</p>

    <p>Compiled：最近编译方法的数量
Size：最近编译方法的字节码数量
Type：最近编译方法的编译类型。
Method：方法名标识。</p>
  </li>
</ol>

<p><a id="org7f45868"></a></p>

<h2 id="典型场景">典型场景</h2>

<ol>
  <li>
    <p>年轻代回收问题</p>

    <p>2022-05-13T10:25:08.601+0800: 885.631: [GC (Allocation Failure) 2022-05-13T10:25:08.601+0800: 885.631: [ParNew: 2831168K-&gt;276173K(2831168K), 0.1156222 secs] 2993638K-&gt;497276K(4928320K), 0.1160069 secs] [Times: user=0.40 sys=0.04, real=0.12 secs]</p>

    <ol>
      <li>原因 年轻的分配内存失败,发生了 YGC</li>
    </ol>
  </li>
  <li>
    <p>CPU爆满问题</p>

    <ol>
      <li>CPU高问题  top -p $PID -H 找到对应高的线程ID</li>
      <li>将线程ID转换为16进制</li>
      <li>jstack 生成stack信息 找到对用的线程ID，即可定位原因</li>
    </ol>
  </li>
  <li>
    <p>ThreadLocal内存泄漏原因</p>

    <ol>
      <li>
        <p>一般是没有remove key 导致持有引用</p>

        <p>key 是weakReference  在GC的时候key会被回收，当key 为null的时候，在get/remove/方法的时候，将key为null的object也移除。
当一个线程创建了对象，但是后续没有机会执行remove/get操作的时候，这些对象可能存在内存泄漏的情况</p>
      </li>
    </ol>
  </li>
</ol>

:ET