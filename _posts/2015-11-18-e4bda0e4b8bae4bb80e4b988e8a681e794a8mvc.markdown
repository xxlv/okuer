---
author: admin
comments: true
date: 2015-11-18 05:56:14+00:00
layout: post
slug: '%e4%bd%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8mvc'
title: 你为什么要用MVC?
wordpress_id: 377
categories:
- PHP
---

现在MVC(HMVC)流行到MVVM的发展,越来越多的框架横空出世.编程逐渐普及,任何人只需要花费一周的时间就可以轻易的熟悉一种框架,假设你有学习c的经历,你熟悉一种新的语言的过程不会超过一周.即使是java或者c++,你仍旧很快能掌握其中的语法规则.这些门槛的降低源于现代互联网的开放,所有的学习资源都可以在线发现,然而我并不是要告诉你如何去迅速掌握一门编程语言.



在我的工作经历中,我接触很多框架,这些开源的产品大都是采用非常棒的设计思想,像是一件艺术品.你总能在读它们的实现中发现令人吃惊的片段:哦,原来可以这么解耦?原来适配器模式可以这么玩?



但在实际的工作中,在我读前辈们写的代码的过程中,我却非常失望的发现,我们都在写面条式的代码.

大多数人认为MVC的存在只是为了分层,让前端和后端分离,并且都是这样用的.大家觉得没什么不好的.

是的,这是不可否认的一点,MVC做出的重大贡献就是让数据,逻辑和视图分离,然而,MVC真的足够了麽?或者这样问?我们分离之后,就这样好了?



事情好像比这复杂的多.我们发现,后端的开发者将精力全部放在了控制器上,model层大都框架提供的,View层有前端配合,那剩下的工作岂不是都交给Controller了?



可悲的是,这就是真相,很多人都开始(包括我自己)在接收到一个Task之后,我们的工作重心都在Controller上面.

从接收一个参数完成初始化到大量的计算甚至直接用db对象操作sql之后生成viewmodel交给框架去渲染view.然后工作完成去吃晚餐.似乎大家觉得没有什么不妥,确实,it is works .



这也解释了为什么大多数人都自嘲为码农.因为你的工作都是这样子的,稍微有点良心的,在Controller里面的代码太多的时候,均出部分来给model层,实在不行,view层也给一些逻辑.最后项目如期完成.



**这样做有问题麽?**

场景 1

现在我们的程序需要增加一个功能,在判断用户是中国国籍的时候,切换系统语言为中文.

场景 2

所有的经过A的信息发送都经过敏感数据过滤

场景3

部分用户的邮件通知短期内禁用



如果你在设计之处没有考虑到多语言的支持,你的所有的语言都是硬编码到程序中的,那么第一个场景出现的时候,我想你可能已经面临被辞退或者主动找个借口走路了.或者你开始你跟的产品经理开撕,这TM是什么需求?接着你在跟BOSS沟通,这是个无法完成的任务,需要重新设计系统



你很幸运,还没有遇到第一种场景,但是你进入了场景2 ,现在你考虑,所有的信息都要过滤,你想到的是,第一,在信息的发送接口层做限制.假设你封装了发送消息的服务msg,你可能在msg上做过滤.但不幸等你修改完毕准备跟女朋友去逛街看电影过两人世界的时候,接到了客户投诉的电话说它发不出去消息了.你一头雾水,查了日志发现,原来该用户属于B用户群,你很机智的增加了if判断,如果是B用户的化,不需要过滤.

你也可能进入了场景3 ,在这里,你做出的解决方案是,在发送邮件的时候,过滤出那部分用户来.

这样做有什么不好?

仔细思考一下你干了什么? 你用了大量的if横切了代码.导致原来msg的功能被复杂化,并增加了未知的风险,使得你无法准确的判断和做出调试.我们知道发送消息就是发送消息,这个功能可能在其他业务里面也有,但是现在你的发送消息逻辑增加了许多业务本身的逻辑,导致它没办法被复用.也许你并没有打算分享出去,但甚至,就连你自己也没办法在下一个project中使用它.于是你复制,粘贴,修改,终于把msg的模块在新的项目中使用了.然后你接着面临了相同的困境.

这只是其中的一个假设.



**不要重复自己!**

很多人觉得写程序很枯燥,其中一个最重要的原因是,你永远在重复自己,你总是你昨天和上周周五写过的片段.然而这些事情,如果在一开始构思好,你完全没必要加班在11点还在写你的代码.不要重复自己,意味着,你在一开始就要对一些可以公用的东西模块化.这些模块将成为你的财富,你需要定期的更新让它进化和健壮.



**大刀阔斧的删除!**

你的能力多强不代表你写了多少行代码,而是你删除了多少行.这意味着,你每天工作不需要8个小时,大多数人一整天的工作,都在一个小时可以完成.剩下的时间你可以做你喜欢做的事情,比如参与github的开源建设,这是对全人类有益的事情.控制层永远不要有太长的代码,你见过哪个控制中心有无数个按钮还有零食还有制造按钮的机器和材料的?

控制器瘦身势在必行,现在看看你的代码,你如果在一分钟之内不能给一个完全没有接触过你代码的人讲清楚你这个action干了那些事,或者你需要拖动滚动条和用tag的形式才能弄清除你的controller的开头和结尾是啥.

那么问题一定在你.

控制器一定要有最清晰的逻辑,在非常复杂的情况下,尽可能用简单的if控制.清晰的逻辑体现在,你的大多数代码都能通过一个屏幕展现.

不要留恋你的代码,除非你觉得你写那段代码的时候经常想起跟你媳妇的海誓山盟泪流满面,否则如果它已经没有用,删掉它.



**不要局限于MVC**

实际上,MVC只是基本配置,你在开发中需要用到Service层,Proxy层等等,在大型的代码中,你可能需要将你的依赖代理,而不是直接使用,这样方便你切换依赖.在控制器中,你不认识db,不认识httpclient.但是你拥有魔法.你只需要想象一个盒子,方便记忆,你给它起一个名字,然后将你的任务交给它们.



一个简单的功能,我要初始化一个注册页面,你需要在控制器中做出做合理的假设(以下只是其中可能的一个):

1 接收post

2 验证数据合法性(可能是过滤链,本form检查,常规检查,特殊性检查,)

3 完成注册功能

那么你的action很清楚了,第一initData,第二,getData,第三 Service.register

这样,你的功能就完成了,你甚至可以将getData内置到initData中.你的控制器可能只有简单的几行.







	
  1. ` class User{`

	
  2. `    public function reg(){`

	
  3. `        `

	
  4. `        $data=User->Reg->Helper->initDataWithReq($this.req);//从初始化的数据中获取注册需要的数据,包括自动格式转化`

	
  5. ``

	
  6. `        $res=RegService->regWith($data);//开始使用这些数据注册`

	
  7. ``

	
  8. `        RegService->regDone($res);  //处理完成之后的后续工作`

	
  9. `                    `

	
  10. `    }`

	
  11. `}`




这只是其中的一个例子,每一种架构都不同,但目的是清晰的,首先控制器是按钮,是摇杆,对于细节它不关心.

比如initDataWithReq中,可能包含了分析req,过滤数据,日志记录,ip记录,自动检查是否数据库存在,这些控制器都不关心,控制在只知道,我将任务交给它,肯定得到的是我要的结果,控制器也没必要检测$data是否合法,因为一定是合法的,不合法的检查都在initData内部.并做了相应的处理.接着控制器将数据交给了注册服务,告诉你开始注册,具体注册的逻辑都不要关心,到底是插入mysql还是sql server还算txt都无所谓,你只管给我注册,我知道你一定由办法,直接处理完之后,我将结果交给注册完成的逻辑.注册完成的逻辑可能是检测成功之后,显示成功页面还是发送到短信,这些细节都被完美的隐藏掉了.

控制器的名言应该是:不要在意这些细节!



细节在盒子内部,控制器拥有魔法可以使用这些盒子,即使这些盒子不存在或者不能完成任务都没关系.所以如果你的注册逻辑是



	
  1. `class User {`

	
  2. `    public function reg(){`

	
  3. `       RegService->initRegEvn();//初始化注册环境`

	
  4. `       RegService->doRegWork();//开始注册`

	
  5. `       RegService->finishRegWrok();//注册收尾      `

	
  6. `    }`

	
  7. ``

	
  8. `}`




或者



	
  1. `class User {`

	
  2. `    public function reg(){`

	
  3. `        RegService->addTasks(['initReg','doReg','finishReg']);`

	
  4. `        return RegService->doTaskUseReq($req);`

	
  5. `    }`

	
  6. ``

	
  7. `}`




都是合理且漂亮的实现.具体选择什么样的实现,就要看业务需求了.



**面向切面+面向对象**



一直以来我们都是面向对象编程的(虽然都是这么说,但有很多人还是直接记流水编程),对于面向切面,只有很少人会这么干,而且就算干了也不讨好,因为很多人都不理解明明很简单的事情,搞出什么事件触发,事件注册,多累啊.是时候面向切面了(对了,啥是面向切面?).



**底层盒子回归函数编程**



大家都知道,面向过程的代码虽然很丑难以维护,但是执行的速度快,现在是时候进行必要的过程编程了!(那岂不是之前扯了那么多都是废话?这你就理解错了)

在Controller层,我们的架构对面向对象的,封装的,可以维护的,但是你记得不,我们的Controller中用到了非常多的魔法盒子,这些盒子都有各自的作用,那么真正的编程应该是基于盒子的编程.

所以,在上面的例子中,对RegService层的编程就可以面向过程了麽?



那你可就大错特错了,还不行,在Service中,我们具体的任务也不能交给过程式,还得根据需要在进行粒度的细化,要知道这些盒子大都是不可复用的,但是针对具体业务的,这部分就需要函数式编程.

所以即使对Service层,你仍旧需要拆分任务(可能).这样做,所以对Service层你仍旧理解为是Service中控制逻辑,具体的Task,是再往下细分的.

在上面的注册例子中,可能的Service层的逻辑是:





	
  1. `public class Helper{`

	
  2. `    public function initDataWithReq($data){
`

	
  3. `        $filter=FilterHepler->addFilters(['reg','keywords','comon']);`

	
  4. `        $clean_data=$filter->hy($data);//净化数据
`

	
  5. `        return $clean_data;  `

	
  6. `      `

	
  7. `    }`

	
  8. ``

	
  9. `}`






	
  1. `public class RegService extends ServiceBase{
`

	
  2. `
`

	
  3. `        public function regWith($data){`

	
  4. `           return DbProxy->getEntity('user')->save($data); `

	
  5. `        }`

	
  6. ``

	
  7. `}
`

`
`




上面的代码只是展示了一种可能的实现,具体的实现有很多例子.但是,最常见的僵局是:过度设计.这些设计应该在权衡项目大小和需求复杂度之后才可以决定了.一味的照搬只会使自己越来越被动.

就想是一味的满足DB的范式.适当的冗余是有益的.


