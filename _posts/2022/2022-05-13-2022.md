---
author: ghost
comments: true
date: 2022-05-13 05:26+00:00
layout: post
title: GraphQL是什么？
categories:

- 技术
---
GraphQL 允许Client来 定制Server 的返回结果。传统的基于Restful的API或者rpc都面临着一个问题，就是Client 没有办法来决定Server返回什么数据。所有的数据的计算过程都是确定的，Client 只需要Send 一个req， 服务端接受到这个请求进行 response.
Client并没有一种语言或者约束规则来影响服务端的执行序列。因此，一个简单的场景，
# 与REST的差异
+ 基于REST的架构产生的请求如下
``` http
GET /user/1
```
将返回如下的对象
``` java
User{
    id
    name
    avatar
    sex
    age
}
```

当Client 仅仅需要一个name 的时候，Client 唯一做的，就是获取到完整的 `User` 对象，然后在浏览器端 进行过滤。 

+ 基于GraphQL 来实现一个相同的功能(通过 `HTTP POST` )
``` graphql
query{
    user{
        name
    }
}
```

Server 端将返回
``` json
{
        "user":{
            "name":"Leslie"
        }

}
```
## 类型系统

GraphQL 定义一个Type System. Type 定义了数据结构与数据约束。

这是的GraphQL成为一种应用层的协议。 通过Type 我们可以定义一个Schema。

Schema 就像是基于REST我们定义的API 信息，如请求参数/返回值。
Schema描述了 Type System 包含的全部信息：

- 所有的查询，都在一个`Query` 的特殊类型下。

- 所有的变更与修改，都在一个`Mutation`下。

- 同时还有一个`Subscription` 用来实现服务端的推送。

一个 简单的Schema 如下

``` 
# user
type User{
    id:ID
    name:String!
    avatar:URL
    sex:Int
    age:Int
} 

type Mutation{
    changeUser(name:String):User!
}

type Query{
    findUser(name:String):User!
}

```
这是一种SDL，描述了 这个Schema包含的查询与变更。 

### 类型
GraphQL 系统支持很多类型

+ Scalar
    - ID
    - Int
    - String
    - ...
+ Object
+ Input
+ Enum
+ _Union_
+ _Interface_

+ **LIST**
+ **NON_NULL**

注意，Scalar 是基本的数据类型，所有的复杂类型，如 Object和Input,都是由于Scalar构成。

Scalar 本身定义的数据 是通过字面量 来传递到Server, GraphQL Server 有能力将一个字符序列通过序列化转换成合适的可以被网络传递的数据流（序列化）。当需要响应指定类型的数据，通过从数据流加载数据并转换成字面量。

-- come soon 






