---
author: admin
comments: true
date: 2015-05-12 03:41:14+00:00
layout: post
slug: php7%e5%86%85%e6%a0%b8%ef%bc%9atsrm
title: PHP7内核：TSRM
wordpress_id: 95
categories:
- PHP
---

TSRM的全名是线程安全资源管理器  (Thread Safe Resource Manager) 。

她位于TSRM目录下，并且只会在当需要明确使用线程安全的时候才会启用，例如apache的多道处理WMP.（[http://httpd.apache.org/docs/2.2/mpm.html](http://httpd.apache.org/docs/2.2/mpm.html)）

在PHP7之前的版本中，使用



	
  1. #define TSRMLS_C tsrm_ls

	
  2. #define TSRMLS_D void *** tsrm_ls

	
  3. #define TSRMLS_CC ,tsrm_ls

	
  4. #define TSRMLS_DS ,void ***tsrm_ls


在PHP7中，使用ZTS宏来判断是否启用了线程安全，在SRC中随处可见

#ifdef ZTS
**do**
#endif

这样的代码。被宏包裹之后，只会在明确要求的时候被编译。

在创建一个extension的时候，将变量的作用于提高到文件作用域（在函数之外定义），可以让全部文件内的函数可见，这在单线程的模型 中是可行的，全局变量可在MINIT/RINIT的时候被创建，在MSHUTDOWN/RSHUTDOWM的时候被回收。因为仅仅这个变量有一个操作者。但是当运行在多线程的模型下的时候，问题出现了，多个线程会对这个全局变量产生竞争。

PHP7提供了一个宏PHP_GINIT_FUNCTION来初始化全局变量，这个宏展开后为：

#define PHP_GINIT_FUNCTION        ZEND_GINIT_FUNCTION

#define ZEND_GINIT_FUNCTION      ZEND_MODULE_GLOBALS_CTOR_D

#define ZEND_MODULE_GLOBALS_CTOR_D(module)  void ZEND_MODULE_GLOBALS_CTOR_N(module)(zend_##module##_globals *module##_globals)

#define ZEND_MODULE_GLOBALS_CTOR_N(module)  zm_globals_ctor_##module



全部宏展开比较复杂,位于Zend/Zend_API.h中，ctor在创建线程的时候被调用，而dtor当销毁的时候被调用。

例如当我的模块名称为json的时候，展开为：

zm_globals_ctor_json(zend_json_globals *json_globals)

如果如何访问一个全局变量呢？

在本例中（PHP7）使用了XX_G或者(XXG)宏来访问全局变量

（下例中位于/ext/json/php_json.h）

#ifdef ZTS
# define JSON_G(v) ZEND_TSRMG(json_globals_id, zend_json_globals *, v)
# ifdef COMPILE_DL_JSON
ZEND_TSRMLS_CACHE_EXTERN;
# endif
#else
# define JSON_G(v) (json_globals.v)
#endif

可以看到，当启用了ZTS的时候，使用ZEND_TSRMG来访问全局变量，而默认使用JSON_G宏来访问。



下面是ZEND_TSRMG的展开结果（/Zend/zend.h）：

#ifdef ZEND_ENABLE_STATIC_TSRMLS_CACHE
#define ZEND_TSRMG TSRMG_STATIC

/*
#define ZEND_TSRMLS_CACHE_EXTERN() TSRMLS_CACHE_EXTERN()
#define ZEND_TSRMLS_CACHE_DEFINE() TSRMLS_CACHE_DEFINE()
#define ZEND_TSRMLS_CACHE_UPDATE() TSRMLS_CACHE_UPDATE()
#define ZEND_TSRMLS_CACHE TSRMLS_CACHE

*/
#else
#define ZEND_TSRMG TSRMG

/*
#define ZEND_TSRMLS_CACHE_EXTERN()
#define ZEND_TSRMLS_CACHE_DEFINE()
#define ZEND_TSRMLS_CACHE_UPDATE()
#define ZEND_TSRMLS_CACHE

*/
#endif



在TSRM/TSRM.H中继续展开如下：

#define TSRMG(id, type, element)    (((type) (*((void ***) tsrm_get_ls_cache()))[TSRM_UNSHUFFLE_RSRC_ID(id)])->element)

#define TSRMG_STATIC(id, type, element)    (((type) (*((void ***) TSRMLS_CACHE))[TSRM_UNSHUFFLE_RSRC_ID(id)])->element)

可以看到，在ZTS下，访问全局变量的时候使用的方式在vector来根访问id来访问。





参考：[http://www.laruence.com/2008/08/03/201.html](http://www.laruence.com/2008/08/03/201.html)
