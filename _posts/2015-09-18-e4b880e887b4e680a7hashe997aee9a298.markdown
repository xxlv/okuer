---
author: admin
comments: true
date: 2015-09-18 14:33:40+00:00
layout: post
slug: '%e4%b8%80%e8%87%b4%e6%80%a7hash%e9%97%ae%e9%a2%98'
title: 一致性hash问题
wordpress_id: 344
categories:
- Hot
---

**什么是一致性hash问题？**


在做cache的时候，好的hash算法应该有如下的判定依据:




1 平衡性




** **平衡性。譬如现在有100台机器做cache，被cache的数据应该均匀分布在这100台机器上以达到资源利用率的最大化。




2 单调性




单调性，是说，假设某hash将A映射到M1这台机器上，如果现在新增加了10台机器做cache，那么应该保证A映射到M1或者新的这10台机器中的一个上，而不要覆盖其他缓冲区。这样做保证了在新增加cache节点后，不至于之前做的cache失效。




3 分散性




分散性则是说，不同的终端（对应于一个ip或者userid之类）看不到所有的缓冲，而是只能看到一部分，当终端通过hash将内容映射到缓冲中时，就可能将相同的缓冲映射到不同的缓冲节点上，降低了存储效率。譬如通过IP映射。




4 负载




负载是说，同一个缓冲区可以cache不同的内容。这也是应该尽量避免的。




 ------------------------------------------------------------------------ -----------------------------------------------------------------------




**下面是译文(忽视我的英文水平)：**




原文链接：http://www.codeproject.com/Articles/56138/Consistent-hashing




 ------------------------------------------------------------------------ -----------------------------------------------------------------------




**为什么需要一致性Hash?**










现在，我们考虑做负载均衡的常用方式，用机器数(n)来选择缓存对象O为：






    
    hash(o) mod n









这里的n是缓存机器的总数，它工作的很好，直到你改变机器的数量。




1 当你增加一个cache 机器，缓存对象o将被缓存到机器：






    
    hash(o) mod (n+1)









2 当你移除一个cache机器，缓存对象o将被缓存到机器：






    
    hash(o) mod (n-1)












所以你可以看到几乎所有的对象都被散列到一个新的位置。这将是一场灾难，因为原始的内容服务器都被缓存机器的的请求淹没




（注:这个缓存群需要rehash）。







一致性hash可以保证当一台cache机器被移除后，仅仅需要将它里面的缓存对象重新缓存。当一台新的cache机器增加，仅仅有部分对象被重新hash。




现在我们一步一步来看一致性Hash。







**Hash空间 (Hash Space)**







通常呢，一个hash方法将映射一个值到32-bit 的key上，0~2^32-1，现在想象映射成一个圆。 then the key will be wrapped




0之后是2^32-1 如figure 1.







![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/1.png)




  (figure 1)




![](file:///C:/Users/tobi/AppData/Local/YNote/data/1252804799@qq.com/93075357994d4b58b8fd447ed447f607/clipboard.png)







**映射对象到Hash空间(Map object into hash space)**







现在考虑4个对象object1~object4,我们用一个hash方法获取它们的key的值，并且映射到这个圆上，如figure 2







![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/2.png)




       (figure 2)









    
    hash(object1)=key1
    ......
    hash(object4)=key2




**映射缓存到Hash空间(Map the cache into hash space)**

一致性Hash的基本观点是同一个Hash方法映射缓存和对象到相同的hash空间。现在考虑我们有三个缓存，A,B和C    ，并且它们的映射结果如figure 3所示.

    
    hash(cache A)=key A
    ......
    hash(cache C)=key C


![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/3.png)



(figure 3)



**映射对象到cache(Map objects into cache)**


现在，所有的缓存和对象都被hash到相同的hash空间内，所以我们可以决定如何映射对象到缓存。举对象obj为例，从obj哪里开始，




从头部在环上顺时针 直到发现一个server.如果这个server是宕机，继续去下一个，如此类推，见 上面的figure 3







**增加或者移除一个cache **




现在考虑两种场景。一个cache宕机并且移除，一个新的cache增加。




如果cache B 被移除，仅仅是cache到B的那个对象需要移动到C上，在这个例子中，见figure 4中的object4.




![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/4.png)




        (figure 4)







如果一个新的cache D 被增加，并且D被hash到环中的object 2与object3之间。仅仅D与B之间的对象需要rehash.这个例子见figure 5.




![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/5.png)







        (figure 5)







**虚拟节点（Virtual nodes）**










如果你不部署足够的缓存，缓存的对象将可能有一个非常不均匀的分布。解决方案是引入”虚拟节点“。




虚拟节点是缓存点的复制。每一个真实的缓存对应于几个圆上的虚拟节点。每当我们增加一个缓存，实际上，我们为它在圆上创建了一个虚拟节点的数字。当一个缓存移除后，我们移除圆上的所有虚拟节点。







考虑到上面的例子，系统中有两个缓存A 和C，并且现在我们引入 虚拟节点，replica  是2。现在3个节点就变成4个虚拟节点。




Cache A1 和Cache A2 代表cache A, Cache C1和Cache C2 代表 cache C.见图6










![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/6.png)




        (figure 6)







接着，映射对象到寻你节点。






    
    objec1->cache A2; objec2->cache A1; objec3->cache C1; objec4->cache C2


![](http://okuers-wordpress.stor.sinaapp.com/uploads/2015/09/7.png)

(figure 7)


当你的获得虚拟节点，你得到的缓存，如上图中所示。




所以object 1 和object 2 被cache到Cache A 和 ,object 3 和object 4 被缓存到cache 中。现在缓存结果更加均匀。







所以现在你知道一致性缓存是啥了吧。（汗！到目前为止还是很模糊啊~）










总结一下：待续













![](file:///C:/Users/tobi/AppData/Local/YNote/data/1252804799@qq.com/93075357994d4b58b8fd447ed447f607/clipboard.png)



